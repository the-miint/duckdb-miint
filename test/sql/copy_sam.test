# name: test/sql/copy_sam.test
# description: Test COPY FORMAT SAM for writing SAM format files
# group: [miint]

require miint

# Test 1: Basic SAM output with header
statement ok
CREATE TABLE sam_test AS SELECT * FROM read_sam('data/sam/foo_has_header.sam');

statement ok
COPY sam_test TO '__TEST_DIR__/basic.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'G1234': 20, 'G000144735': 90});

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/basic.sam');
----
4

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 2: SAM output without header (INCLUDE_HEADER=false)
statement ok
COPY sam_test TO '__TEST_DIR__/no_header.sam' (FORMAT SAM, INCLUDE_HEADER false);

# When reading back headerless files, we need to provide reference_lengths
query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/no_header.sam', reference_lengths = MAP{'G1234': 20, 'G000144735': 90});
----
4

# Test 3: SAM output with header (INCLUDE_HEADER=true, explicit)
statement ok
COPY sam_test TO '__TEST_DIR__/with_header.sam' (FORMAT SAM, INCLUDE_HEADER true, REFERENCE_LENGTHS MAP{'G1234': 20, 'G000144735': 90});

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/with_header.sam') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 4: SAM with tags
statement ok
CREATE TABLE sam_tags_test AS SELECT * FROM read_sam('data/sam/foo_with_tags.sam');

statement ok
COPY sam_tags_test TO '__TEST_DIR__/with_tags.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'G1234': 1000, 'G000144735': 100000});

query IIIIII
SELECT read_id, flags, reference, position, mapq, tag_as FROM read_sam('__TEST_DIR__/with_tags.sam') ORDER BY read_id;
----
tagged-1	0	G1234	10	60	100
tagged-2	99	G000144735	1000	30	200

# Test 5: Empty table with header
statement ok
CREATE TABLE empty_sam AS SELECT * FROM sam_test WHERE 1=0;

statement ok
COPY empty_sam TO '__TEST_DIR__/empty.sam' (FORMAT SAM, INCLUDE_HEADER true, REFERENCE_LENGTHS MAP{'G1234': 20});

# Test 6: SAM without header for empty table
statement ok
COPY empty_sam TO '__TEST_DIR__/empty_no_header.sam' (FORMAT SAM, INCLUDE_HEADER false);

# Test 7: Large positions
statement ok
CREATE TABLE large_pos_test AS SELECT * FROM read_sam('data/sam/foo_large_positions.sam');

statement ok
COPY large_pos_test TO '__TEST_DIR__/large_pos.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'chrLarge': 3000000000});

query III
SELECT read_id, position, stop_position FROM read_sam('__TEST_DIR__/large_pos.sam') ORDER BY read_id;
----
large-pos	2147483648	2147483748

# Test 8: Verify CIGAR string preservation
query II
SELECT read_id, cigar FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	10M
foo-2	10M
foo-3	150M
foo-3	150M

# Test 9: Verify mate information preservation
query IIII
SELECT read_id, mate_reference, mate_position, template_length FROM read_sam('__TEST_DIR__/basic.sam') WHERE read_id = 'foo-3' ORDER BY position;
----
foo-3	=	76146	276
foo-3	=	76020	-276

# Test 10: Test GZIP compression
statement ok
COPY sam_test TO '__TEST_DIR__/compressed.sam.gz' (FORMAT SAM, COMPRESSION gzip, REFERENCE_LENGTHS MAP{'G1234': 20, 'G000144735': 90});

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/compressed.sam.gz');
----
4

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/compressed.sam.gz') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 11: Test GZIP compression without header
statement ok
COPY sam_test TO '__TEST_DIR__/compressed_no_header.sam.gz' (FORMAT SAM, COMPRESSION gzip, INCLUDE_HEADER false);

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/compressed_no_header.sam.gz', reference_lengths = MAP{'G1234': 20, 'G000144735': 90});
----
4

# Test 12: Verify flags are preserved correctly
query II
SELECT read_id, flags FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	0
foo-2	0
foo-3	99
foo-3	147

# Test 13: Test with minimal SAM columns (no tags)
statement ok
CREATE TABLE no_tags_test AS SELECT * FROM read_sam('data/sam/foo_no_tags.sam');

statement ok
COPY no_tags_test TO '__TEST_DIR__/no_tags.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'G1234': 1000});

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/no_tags.sam');
----
1

# Test 14: Round-trip with all NULL tag values
query IIIIIIII
SELECT tag_as, tag_xs, tag_ys, tag_xn, tag_xm, tag_xo, tag_xg, tag_nm FROM read_sam('__TEST_DIR__/no_tags.sam') ORDER BY read_id;
----
NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

# Test 15: Verify * values for unmapped reads (needs a dummy reference for headerless file)
statement ok
CREATE TABLE unmapped AS SELECT 'unmapped-1' as read_id, 4::UINT16 as flags, '*' as reference, 0::INT64 as position, 0::INT64 as stop_position, 0::UINT8 as mapq, '*' as cigar, '*' as mate_reference, 0::INT64 as mate_position, 0::INT64 as template_length, NULL::INT64 as tag_as, NULL::INT64 as tag_xs, NULL::INT64 as tag_ys, NULL::INT64 as tag_xn, NULL::INT64 as tag_xm, NULL::INT64 as tag_xo, NULL::INT64 as tag_xg, NULL::INT64 as tag_nm, NULL::VARCHAR as tag_yt, NULL::VARCHAR as tag_md, NULL::VARCHAR as tag_sa;

statement ok
COPY unmapped TO '__TEST_DIR__/unmapped.sam' (FORMAT SAM, INCLUDE_HEADER false);

query IIII
SELECT read_id, flags, reference, position FROM read_sam('__TEST_DIR__/unmapped.sam', reference_lengths = MAP{'dummy': 1000});
----
unmapped-1	4	*	0

# Test 16: Verify MAPQ encoding
query II
SELECT read_id, mapq FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	60
foo-2	60
foo-3	1
foo-3	1

# Test 17: Multiple references in header
query I
SELECT COUNT(DISTINCT reference) FROM read_sam('__TEST_DIR__/basic.sam');
----
2

# Test 18: Test error on missing required columns
statement error
COPY (SELECT read_id FROM sam_test) TO '__TEST_DIR__/error.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'G1234': 20});
----
COPY FORMAT SAM requires 'flags' column

# Test 19: Test error on wrong column types
statement error
COPY (SELECT read_id, 'wrong'::VARCHAR as flags, reference, position, mapq, cigar, mate_reference, mate_position, template_length FROM sam_test) TO '__TEST_DIR__/error.sam' (FORMAT SAM, REFERENCE_LENGTHS MAP{'G1234': 20});
----
Column 'flags' must be USMALLINT

# Test 20: Test error when INCLUDE_HEADER=true without REFERENCE_LENGTHS
statement error
COPY sam_test TO '__TEST_DIR__/error.sam' (FORMAT SAM);
----
COPY FORMAT SAM with INCLUDE_HEADER=true requires REFERENCE_LENGTHS parameter

# Test 21: Verify sequence and quality score preservation (if provided)
# Note: Our test data uses * for sequence and quality, which should be preserved
statement ok
CREATE TABLE with_seq AS SELECT 'read-seq' as read_id, 0::UINT16 as flags, 'ref1' as reference, 1::INT64 as position, 4::INT64 as stop_position, 30::UINT8 as mapq, '4M' as cigar, '*' as mate_reference, 0::INT64 as mate_position, 0::INT64 as template_length, NULL::INT64 as tag_as, NULL::INT64 as tag_xs, NULL::INT64 as tag_ys, NULL::INT64 as tag_xn, NULL::INT64 as tag_xm, NULL::INT64 as tag_xo, NULL::INT64 as tag_xg, NULL::INT64 as tag_nm, NULL::VARCHAR as tag_yt, NULL::VARCHAR as tag_md, NULL::VARCHAR as tag_sa;

statement ok
COPY with_seq TO '__TEST_DIR__/with_seq.sam' (FORMAT SAM, INCLUDE_HEADER false);

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/with_seq.sam', reference_lengths = MAP{'ref1': 100});
----
read-seq	0	ref1	1	30
