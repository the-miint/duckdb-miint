# name: test/sql/copy_sam.test
# description: Test COPY FORMAT SAM for writing SAM format files
# group: [sql]

require miint

# Test 1: Basic SAM output with header
statement ok
CREATE TABLE sam_test AS SELECT * FROM read_sam('data/sam/foo_has_header.sam');

statement ok
CREATE TABLE ref_table AS SELECT 'G1234' AS name, 20 AS length UNION ALL SELECT 'G000144735', 90;

statement ok
COPY sam_test TO '__TEST_DIR__/basic.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table');

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/basic.sam');
----
4

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 2: SAM output without header (INCLUDE_HEADER=false)
statement ok
COPY sam_test TO '__TEST_DIR__/no_header.sam' (FORMAT SAM, INCLUDE_HEADER false, REFERENCE_LENGTHS 'ref_table');

# When reading back headerless files, we need to provide reference_lengths (using table)
query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/no_header.sam', reference_lengths='ref_table');
----
4

# Test 3: SAM output with header (INCLUDE_HEADER=true, explicit)
statement ok
COPY sam_test TO '__TEST_DIR__/with_header.sam' (FORMAT SAM, INCLUDE_HEADER true, REFERENCE_LENGTHS 'ref_table');

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/with_header.sam') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 4: SAM with tags
statement ok
CREATE TABLE sam_tags_test AS SELECT * FROM read_sam('data/sam/foo_with_tags.sam');

statement ok
CREATE TABLE ref_table_tags AS SELECT 'G1234' AS name, 1000 AS length UNION ALL SELECT 'G000144735', 100000;

statement ok
COPY sam_tags_test TO '__TEST_DIR__/with_tags.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table_tags');

query IIIIII
SELECT read_id, flags, reference, position, mapq, tag_as FROM read_sam('__TEST_DIR__/with_tags.sam') ORDER BY read_id;
----
tagged-1	0	G1234	10	60	100
tagged-2	99	G000144735	1000	30	200

# Test 5: Empty table with header
statement ok
CREATE TABLE empty_sam AS SELECT * FROM sam_test WHERE 1=0;

statement ok
CREATE TABLE ref_table_single AS SELECT 'G1234' AS name, 20 AS length;

statement ok
COPY empty_sam TO '__TEST_DIR__/empty.sam' (FORMAT SAM, INCLUDE_HEADER true, REFERENCE_LENGTHS 'ref_table_single');

# Test 6: SAM without header for empty table
statement ok
COPY empty_sam TO '__TEST_DIR__/empty_no_header.sam' (FORMAT SAM, INCLUDE_HEADER false, REFERENCE_LENGTHS 'ref_table_single');

# Test 7: Large positions
statement ok
CREATE TABLE large_pos_test AS SELECT * FROM read_sam('data/sam/foo_large_positions.sam');

statement ok
CREATE TABLE ref_table_large AS SELECT 'chrLarge' AS name, 3000000000 AS length;

statement ok
COPY large_pos_test TO '__TEST_DIR__/large_pos.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table_large');

query III
SELECT read_id, position, stop_position FROM read_sam('__TEST_DIR__/large_pos.sam') ORDER BY read_id;
----
large-pos	1147483647	1147483747

# Test 8: Verify CIGAR string preservation
query II
SELECT read_id, cigar FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	10M
foo-2	10M
foo-3	150M
foo-3	150M

# Test 9: Verify mate information preservation
query IIII
SELECT read_id, mate_reference, mate_position, template_length FROM read_sam('__TEST_DIR__/basic.sam') WHERE read_id = 'foo-3' ORDER BY position;
----
foo-3	=	76146	276
foo-3	=	76020	-276

# Test 10: Test GZIP compression
statement ok
COPY sam_test TO '__TEST_DIR__/compressed.sam.gz' (FORMAT SAM, COMPRESSION gzip, REFERENCE_LENGTHS 'ref_table');

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/compressed.sam.gz');
----
4

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/compressed.sam.gz') ORDER BY read_id, position;
----
foo-1	0	G1234	2	60
foo-2	0	G1234	2	60
foo-3	99	G000144735	76020	1
foo-3	147	G000144735	76146	1

# Test 11: Test GZIP compression without header
statement ok
COPY sam_test TO '__TEST_DIR__/compressed_no_header.sam.gz' (FORMAT SAM, COMPRESSION gzip, INCLUDE_HEADER false, REFERENCE_LENGTHS 'ref_table');

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/compressed_no_header.sam.gz', reference_lengths='ref_table');
----
4

# Test 12: Verify flags are preserved correctly
query II
SELECT read_id, flags FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	0
foo-2	0
foo-3	99
foo-3	147

# Test 13: Test with minimal SAM columns (no tags)
statement ok
CREATE TABLE no_tags_test AS SELECT * FROM read_sam('data/sam/foo_no_tags.sam');

statement ok
COPY no_tags_test TO '__TEST_DIR__/no_tags.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table_single');

query I
SELECT COUNT(*) FROM read_sam('__TEST_DIR__/no_tags.sam');
----
1

# Test 14: Round-trip with all NULL tag values
query IIIIIIII
SELECT tag_as, tag_xs, tag_ys, tag_xn, tag_xm, tag_xo, tag_xg, tag_nm FROM read_sam('__TEST_DIR__/no_tags.sam') ORDER BY read_id;
----
NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

# Test 15: Verify * values for unmapped reads (needs a dummy reference for headerless file)
statement ok
CREATE TABLE unmapped AS SELECT 'unmapped-1' as read_id, 4::UINT16 as flags, '*' as reference, 0::INT64 as position, 0::INT64 as stop_position, 0::UINT8 as mapq, '*' as cigar, '*' as mate_reference, 0::INT64 as mate_position, 0::INT64 as template_length, NULL::INT64 as tag_as, NULL::INT64 as tag_xs, NULL::INT64 as tag_ys, NULL::INT64 as tag_xn, NULL::INT64 as tag_xm, NULL::INT64 as tag_xo, NULL::INT64 as tag_xg, NULL::INT64 as tag_nm, NULL::VARCHAR as tag_yt, NULL::VARCHAR as tag_md, NULL::VARCHAR as tag_sa;

statement ok
CREATE TABLE ref_table_dummy AS SELECT 'dummy' AS name, 1000 AS length;

statement ok
COPY unmapped TO '__TEST_DIR__/unmapped.sam' (FORMAT SAM, INCLUDE_HEADER false, REFERENCE_LENGTHS 'ref_table_dummy');

query IIII
SELECT read_id, flags, reference, position FROM read_sam('__TEST_DIR__/unmapped.sam', reference_lengths='ref_table_dummy');
----
unmapped-1	4	*	0

# Test 16: Verify MAPQ encoding
query II
SELECT read_id, mapq FROM read_sam('__TEST_DIR__/basic.sam') ORDER BY read_id, position;
----
foo-1	60
foo-2	60
foo-3	1
foo-3	1

# Test 17: Multiple references in header
query I
SELECT COUNT(DISTINCT reference) FROM read_sam('__TEST_DIR__/basic.sam');
----
2

# Test 18: Test error on missing required columns
statement error
COPY (SELECT read_id FROM sam_test) TO '__TEST_DIR__/error.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table_single');
----
COPY FORMAT SAM requires 'flags' column

# Test 19: Test error on wrong column types
statement error
COPY (SELECT read_id, 'wrong'::VARCHAR as flags, reference, position, mapq, cigar, mate_reference, mate_position, template_length FROM sam_test) TO '__TEST_DIR__/error.sam' (FORMAT SAM, REFERENCE_LENGTHS 'ref_table_single');
----
Column 'flags' must be USMALLINT

# Test 20: Test error when missing REFERENCE_LENGTHS (always required)
statement error
COPY sam_test TO '__TEST_DIR__/error.sam' (FORMAT SAM);
----
COPY FORMAT SAM requires REFERENCE_LENGTHS parameter

# Test 21: Verify sequence and quality score preservation (if provided)
# Note: Our test data uses * for sequence and quality, which should be preserved
statement ok
CREATE TABLE with_seq AS SELECT 'read-seq' as read_id, 0::UINT16 as flags, 'ref1' as reference, 1::INT64 as position, 4::INT64 as stop_position, 30::UINT8 as mapq, '4M' as cigar, '*' as mate_reference, 0::INT64 as mate_position, 0::INT64 as template_length, NULL::INT64 as tag_as, NULL::INT64 as tag_xs, NULL::INT64 as tag_ys, NULL::INT64 as tag_xn, NULL::INT64 as tag_xm, NULL::INT64 as tag_xo, NULL::INT64 as tag_xg, NULL::INT64 as tag_nm, NULL::VARCHAR as tag_yt, NULL::VARCHAR as tag_md, NULL::VARCHAR as tag_sa;

statement ok
CREATE TABLE ref_table_seq AS SELECT 'ref1' AS name, 100 AS length;

statement ok
COPY with_seq TO '__TEST_DIR__/with_seq.sam' (FORMAT SAM, INCLUDE_HEADER false, REFERENCE_LENGTHS 'ref_table_seq');

query IIIII
SELECT read_id, flags, reference, position, mapq FROM read_sam('__TEST_DIR__/with_seq.sam', reference_lengths='ref_table_seq');
----
read-seq	0	ref1	1	30
