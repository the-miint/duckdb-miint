# name: test/sql/align_minimap2.test
# description: Test align_minimap2 table function
# group: [sql]

require miint

# Setup: Create test tables with sequence data

statement ok
CREATE TABLE subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC'),
    ('ref2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA')
) AS t(read_id, sequence1);

statement ok
CREATE TABLE queries AS SELECT * FROM (VALUES
    ('query1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT'),
    ('query2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCA')
) AS t(read_id, sequence1);

# Test basic alignment (using max_secondary=0 to get only primary alignments)
query IIII
SELECT read_id, reference, position, mapq >= 0 as has_mapq
FROM align_minimap2('queries', subject_table='subjects', max_secondary=0)
ORDER BY read_id, reference;
----
query1	ref1	1	true
query2	ref2	1	true

# Test CIGAR string is generated
query II
SELECT read_id, cigar != '*' AND cigar != '' as has_cigar
FROM align_minimap2('queries', subject_table='subjects', max_secondary=0)
ORDER BY read_id;
----
query1	true
query2	true

# Test with EQX mode (default is on, so CIGAR should have = for matches)
query II
SELECT read_id, cigar LIKE '%=%' as has_eq_op
FROM align_minimap2('queries', subject_table='subjects', max_secondary=0)
ORDER BY read_id;
----
query1	true
query2	true

# Test alignment score tag
query II
SELECT read_id, tag_as > 0 as has_score
FROM align_minimap2('queries', subject_table='subjects', max_secondary=0)
ORDER BY read_id;
----
query1	true
query2	true

# Test stop_position is computed
query III
SELECT read_id, position, stop_position >= position as stop_after_start
FROM align_minimap2('queries', subject_table='subjects', max_secondary=0)
ORDER BY read_id;
----
query1	1	true
query2	1	true

# Test with different preset (map-ont uses smaller k, so still aligns)
query II
SELECT read_id, reference
FROM align_minimap2('queries', subject_table='subjects', preset='map-ont', max_secondary=0)
ORDER BY read_id;
----
query1	ref1
query2	ref2

# Test with views
statement ok
CREATE VIEW query_view AS SELECT * FROM queries;

statement ok
CREATE VIEW subject_view AS SELECT * FROM subjects;

query II
SELECT read_id, reference
FROM align_minimap2('query_view', subject_table='subject_view', max_secondary=0)
ORDER BY read_id;
----
query1	ref1
query2	ref2

# Test max_secondary parameter (should limit secondary alignments)
# Create a reference with identical sequences
statement ok
CREATE TABLE multi_subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC'),
    ('ref2', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC'),
    ('ref3', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC')
) AS t(read_id, sequence1);

statement ok
CREATE TABLE single_query AS SELECT * FROM (VALUES
    ('q1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT')
) AS t(read_id, sequence1);

# With max_secondary=0, should get at most 1 alignment
query I
SELECT COUNT(*) <= 1 as limited
FROM align_minimap2('single_query', subject_table='multi_subjects', max_secondary=0);
----
true

# Test error: non-existent query table
statement error
SELECT * FROM align_minimap2('nonexistent_table', subject_table='subjects');
----
does not exist

# Test error: non-existent subject table
statement error
SELECT * FROM align_minimap2('queries', subject_table='nonexistent_table');
----
does not exist

# Test error: subject table with paired data (sequence2)
statement ok
CREATE TABLE paired_subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT', 'TGCATGCATGCATGCATGCATGCA')
) AS t(read_id, sequence1, sequence2);

statement error
SELECT * FROM align_minimap2('queries', subject_table='paired_subjects');
----
cannot be paired-end

# Clean up
statement ok
DROP TABLE subjects;

statement ok
DROP TABLE queries;

statement ok
DROP VIEW query_view;

statement ok
DROP VIEW subject_view;

statement ok
DROP TABLE multi_subjects;

statement ok
DROP TABLE single_query;

statement ok
DROP TABLE paired_subjects;
# Test reading from table created by read_fastx with all columns
# This reproduces a bug where sequence2/qual1/qual2 columns (even if NULL)
# cause incorrect sequence lengths to be passed to minimap2

statement ok
CREATE OR REPLACE TABLE fastx_queries AS SELECT * FROM read_fastx('data/fastq/test.fa');

statement ok
CREATE TABLE fastx_subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC'),
    ('ref2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAGGCCGGCCGGCCATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA')
) AS t(read_id, sequence1);

# This should work even though fastx_queries has sequence2/qual1/qual2 columns with NULLs
query II
SELECT read_id, reference
FROM align_minimap2('fastx_queries', subject_table='fastx_subjects', max_secondary=0, k := 5)
ORDER BY read_id;
----

statement ok
DROP TABLE fastx_queries;

statement ok
DROP TABLE fastx_subjects;

# Test: Save minimap2 index and load it back
statement ok
CREATE TABLE index_test_subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC'),
    ('ref2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA')
) AS t(read_id, sequence1);

statement ok
CREATE TABLE index_test_queries AS SELECT * FROM (VALUES
    ('query1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT'),
    ('query2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCA')
) AS t(read_id, sequence1);

# Save index to file
query III
SELECT success, num_subjects > 0 as has_subjects, index_path LIKE '%test_index.mmi%' as path_matches
FROM save_minimap2_index('index_test_subjects', 'test_index.mmi', k := 5);
----
true	true	true

# Use saved index for alignment
query IIII
SELECT read_id, reference, position, mapq >= 0 as has_mapq
FROM align_minimap2('index_test_queries', index_path='test_index.mmi', max_secondary=0)
ORDER BY read_id, reference;
----
query1	ref1	1	true
query2	ref2	1	true

# Test: Compare results between table-based and index-based alignment
query IIII
SELECT read_id, reference, position, LENGTH(cigar) > 0 as has_cigar
FROM align_minimap2('index_test_queries', subject_table='index_test_subjects', max_secondary=0, k := 5)
ORDER BY read_id;
----
query1	ref1	1	true
query2	ref2	1	true

# NOTE: Index files (test_index.mmi, test_index2.mmi, invalid.txt)
# are left in working directory - DuckDB test framework will clean them up

# Test error: both subject_table and index_path provided
statement error
SELECT * FROM align_minimap2('index_test_queries', subject_table='index_test_subjects', index_path='test_index.mmi');
----
Cannot specify both subject_table and index_path

# Test error: neither subject_table nor index_path provided
statement error
SELECT * FROM align_minimap2('index_test_queries');
----
requires either subject_table or index_path

# Test error: index file doesn't exist
statement error
SELECT * FROM align_minimap2('index_test_queries', index_path='nonexistent.mmi');
----
Index file does not exist

# Test error: file is not a valid index
statement ok
CREATE TABLE invalid_index_file AS SELECT 'not an index' as content;

statement ok
COPY invalid_index_file TO 'invalid.txt';

statement error
SELECT * FROM align_minimap2('index_test_queries', index_path='invalid.txt');
----
not a valid minimap2 index

# Test error: per_subject_database incompatible with index_path
statement error
SELECT * FROM align_minimap2('index_test_queries', index_path='test_index.mmi', per_subject_database=true);
----
per_subject_database mode is incompatible with index_path

# Test: save_minimap2_index with different preset
query III
SELECT success, num_subjects, index_path LIKE '%test_index2.mmi%' as path_matches
FROM save_minimap2_index('index_test_subjects', 'test_index2.mmi', preset='map-ont', k := 8);
----
true	2	true

# Test: Use index saved with different preset
query II
SELECT read_id, reference
FROM align_minimap2('index_test_queries', index_path='test_index2.mmi', max_secondary=0)
ORDER BY read_id;
----
query1	ref1
query2	ref2

# Test error: save_minimap2_index with empty subject table
statement ok
CREATE TABLE empty_subjects AS SELECT * FROM (VALUES ('empty', 'A')) AS t(read_id, sequence1) WHERE FALSE;

statement error
SELECT * FROM save_minimap2_index('empty_subjects', 'empty_index.mmi');
----
is empty

# Clean up
statement ok
DROP TABLE index_test_subjects;

statement ok
DROP TABLE index_test_queries;

statement ok
DROP TABLE invalid_index_file;

statement ok
DROP TABLE empty_subjects;
