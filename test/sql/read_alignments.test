# name: test/sql/read_alignments.test
# description: Tests for read_alignments function (SAM/BAM reading)
# group: [sql]

# Test that the extension loads
require miint

### Phase 2.1 Tests: Basic SAM reading with renamed function

# Basic SAM reading (verify rename works)
statement ok
SELECT * FROM read_alignments('data/sam/foo_has_header.sam')

# Verify read_sam macro alias works for backward compatibility
statement ok
SELECT * FROM read_sam('data/sam/foo_has_header.sam')

# Error: file does not exist
statement error
SELECT * FROM read_alignments('nonexistent.sam')
----
File not found

# Verify same output as before rename
query IIIIIII
SELECT read_id, flags, reference, position, mapq, cigar, mate_reference
FROM read_alignments('data/sam/foo_has_header.sam')
ORDER BY read_id
----
foo-1	0	G1234	2	60	10M	*
foo-2	0	G1234	2	60	10M	*
foo-3	99	G000144735	76020	1	150M	=
foo-3	147	G000144735	76146	1	150M	=

# Test with array of files
query I
SELECT COUNT(*) FROM read_alignments(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam'])
----
8

# Test include_filepath parameter
query II
SELECT read_id, COUNT(DISTINCT filepath)
FROM read_alignments(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam'], include_filepath=true)
GROUP BY read_id
ORDER BY read_id
----
bar-1	1
bar-2	1
bar-3	1
foo-1	1
foo-2	1
foo-3	1

### Phase 2.2 Tests: BAM reading support

# Basic BAM reading - count records
query I
SELECT COUNT(*) FROM read_alignments('data/sam/foo_has_header.bam')
----
4

# Verify BAM output matches SAM output
query IIIIIII
SELECT read_id, flags, reference, position, mapq, cigar, mate_reference
FROM read_alignments('data/sam/foo_has_header.bam')
ORDER BY read_id
----
foo-1	0	G1234	2	60	10M	*
foo-2	0	G1234	2	60	10M	*
foo-3	99	G000144735	76020	1	150M	=
foo-3	147	G000144735	76146	1	150M	=

# BAM with tags
query I
SELECT COUNT(*) FROM read_alignments('data/sam/foo_with_tags.bam')
----
2

# Test reading BAM with array of files
query I
SELECT COUNT(*) FROM read_alignments(['data/sam/foo_has_header.bam', 'data/sam/foo_has_header_2.bam'])
----
8

# Mixed SAM and BAM files
query I
SELECT COUNT(*) FROM read_alignments(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header.bam'])
----
8

# BAM with large positions (test BIGINT handling)
query II
SELECT position, stop_position
FROM read_alignments('data/sam/foo_large_positions.bam')
ORDER BY position
----
2147483648	2147483748

# BAM with include_filepath parameter
query II
SELECT read_id, filepath
FROM read_alignments('data/sam/foo_has_header.bam', include_filepath=true)
ORDER BY read_id
LIMIT 2
----
foo-1	data/sam/foo_has_header.bam
foo-2	data/sam/foo_has_header.bam

# Error: reference_lengths not allowed for BAM (BAM always has headers)
statement error
CREATE TABLE ref_table AS SELECT 'genome1' AS name, 1000 AS length;
SELECT * FROM read_alignments('data/sam/foo_has_header.bam', reference_lengths='ref_table')
----
BAM file has header

# Test include_seq_qual parameter - default false (no sequence/qual columns)
query I
SELECT COUNT(*) FROM (DESCRIBE SELECT * FROM read_alignments('data/sam/foo_with_seqqual.sam')) WHERE column_name IN ('sequence', 'qual')
----
0

# Test include_seq_qual=true adds sequence and qual columns
query I
SELECT COUNT(*) FROM (DESCRIBE SELECT * FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true)) WHERE column_name IN ('sequence', 'qual')
----
2

# Test sequence and qual data types
query TT
SELECT column_name, column_type FROM (DESCRIBE SELECT * FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true)) WHERE column_name IN ('sequence', 'qual') ORDER BY column_name
----
qual	UTINYINT[]
sequence	VARCHAR

# Test actual sequence and quality values
query TTII
SELECT read_id, sequence, list_extract(qual, 1) as first_qual, len(sequence) as seq_len
FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true)
WHERE read_id = 'read1'
----
read1	ACGTACGTAC	0	10

# Test that sequence and quality lengths match
query I
SELECT COUNT(*) FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true)
WHERE len(sequence) = len(qual)
----
5

# Test include_seq_qual with include_filepath
query III
SELECT COUNT(*), COUNT(DISTINCT sequence), COUNT(DISTINCT filepath)
FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true, include_filepath=true)
----
5	5	1

# Test quality score values (should be 0-93 range)
query II
SELECT MIN(list_min(qual)), MAX(list_max(qual))
FROM read_alignments('data/sam/foo_with_seqqual.sam', include_seq_qual=true)
WHERE len(qual) > 0
----
0	41

# Test with multiple files
query I
SELECT COUNT(DISTINCT sequence)
FROM read_alignments(['data/sam/foo_with_seqqual.sam', 'data/sam/foo_with_seqqual.sam'], include_seq_qual=true)
----
5

# Test read_sam alias with include_seq_qual
query I
SELECT COUNT(*) FROM (DESCRIBE SELECT * FROM read_sam('data/sam/foo_with_seqqual.sam', include_seq_qual=true)) WHERE column_name IN ('sequence', 'qual')
----
2

# Test unmapped reads with missing SEQ/QUAL (should fail - unmapped reads must have SEQ/QUAL)
statement error
SELECT read_id, len(sequence)
FROM read_alignments('data/sam/foo_unmapped_no_seq.sam', include_seq_qual=true)
ORDER BY read_id
----
Primary/unmapped read missing sequence
