# name: test/sql/align_minimap2_sharded.test
# description: Test align_minimap2_sharded table function
# group: [sql]

require miint

# Setup: Create test tables

statement ok
CREATE TABLE queries AS SELECT * FROM (VALUES
    ('query1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT'),
    ('query2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCA'),
    ('query3', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
) AS t(read_id, sequence1);

statement ok
CREATE TABLE read_to_shard AS SELECT * FROM (VALUES
    ('query1', 'shard_a'),
    ('query2', 'shard_b'),
    ('query3', 'shard_a')
) AS t(read_id, shard_name);

# ==============================================================================
# ERROR HANDLING TESTS (Fail Fast)
# ==============================================================================

# Test error: missing shard_directory parameter
statement error
SELECT * FROM align_minimap2_sharded('queries', read_to_shard := 'read_to_shard');
----
requires shard_directory parameter

# Test error: missing read_to_shard parameter
statement error
SELECT * FROM align_minimap2_sharded('queries', shard_directory := 'data/shards/');
----
requires read_to_shard parameter

# Test error: non-existent query table
statement error
SELECT * FROM align_minimap2_sharded('nonexistent_table',
    shard_directory := 'data/shards/',
    read_to_shard := 'read_to_shard');
----
does not exist

# Test error: non-existent read_to_shard table
statement error
SELECT * FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'nonexistent_mapping');
----
does not exist

# Test error: read_to_shard missing read_id column
statement ok
CREATE TABLE bad_mapping_no_read_id AS SELECT * FROM (VALUES
    ('shard_a'),
    ('shard_b')
) AS t(shard_name);

statement error
SELECT * FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'bad_mapping_no_read_id');
----
read_id

# Test error: read_to_shard missing shard_name column
statement ok
CREATE TABLE bad_mapping_no_shard AS SELECT * FROM (VALUES
    ('query1'),
    ('query2')
) AS t(read_id);

statement error
SELECT * FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'bad_mapping_no_shard');
----
shard_name

# Test error: shard_directory does not exist
statement error
SELECT * FROM align_minimap2_sharded('queries',
    shard_directory := 'nonexistent_directory/',
    read_to_shard := 'read_to_shard');
----
does not exist

# Test error: shard .mmi file does not exist
statement ok
CREATE TABLE mapping_missing_shard AS SELECT * FROM (VALUES
    ('query1', 'missing_shard')
) AS t(read_id, shard_name);

statement error
SELECT * FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'mapping_missing_shard');
----
does not exist

# Clean up error test tables
statement ok
DROP TABLE bad_mapping_no_read_id;

statement ok
DROP TABLE bad_mapping_no_shard;

statement ok
DROP TABLE mapping_missing_shard;

# ==============================================================================
# BASIC FUNCTIONALITY TESTS (need actual shard .mmi files)
# ==============================================================================

# Create shard indexes from subject sequences
statement ok
CREATE TABLE shard_a_subjects AS SELECT * FROM (VALUES
    ('ref1', 'ACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCCTTAAGGCC')
) AS t(read_id, sequence1);

statement ok
CREATE TABLE shard_b_subjects AS SELECT * FROM (VALUES
    ('ref2', 'TGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCATGCAAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA')
) AS t(read_id, sequence1);

# Save shard indexes
query I
SELECT success FROM save_minimap2_index('shard_a_subjects', 'data/shards/shard_a.mmi', k := 5);
----
true

query I
SELECT success FROM save_minimap2_index('shard_b_subjects', 'data/shards/shard_b.mmi', k := 5);
----
true

# Test basic alignment with shards
# query1 -> shard_a (should align to ref1)
# query2 -> shard_b (should align to ref2)
# query3 -> shard_a (may not align as sequence is all A's)
query II
SELECT read_id, reference
FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'read_to_shard',
    max_secondary := 0)
WHERE flags & 4 = 0
ORDER BY read_id;
----
query1	ref1
query2	ref2

# Test that unmapped reads are filtered out (flags & 4 != 0 should be excluded)
query I
SELECT COUNT(*) FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'read_to_shard',
    max_secondary := 0)
WHERE flags & 4 != 0;
----
0

# ==============================================================================
# READ-TO-MULTIPLE-SHARDS TEST
# ==============================================================================

# Test: Same read maps to multiple shards - should get results from both
statement ok
CREATE TABLE multi_shard_mapping AS SELECT * FROM (VALUES
    ('query1', 'shard_a'),
    ('query1', 'shard_b')
) AS t(read_id, shard_name);

# query1 aligns to shard_a (ref1) but not shard_b (different sequence)
query II
SELECT read_id, reference
FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'multi_shard_mapping',
    max_secondary := 0)
ORDER BY read_id, reference;
----
query1	ref1

statement ok
DROP TABLE multi_shard_mapping;

# ==============================================================================
# VIEW SUPPORT TEST
# ==============================================================================

statement ok
CREATE VIEW query_view AS SELECT * FROM queries;

statement ok
CREATE VIEW mapping_view AS SELECT * FROM read_to_shard;

query II
SELECT read_id, reference
FROM align_minimap2_sharded('query_view',
    shard_directory := 'data/shards/',
    read_to_shard := 'mapping_view',
    max_secondary := 0)
WHERE flags & 4 = 0
ORDER BY read_id;
----
query1	ref1
query2	ref2

statement ok
DROP VIEW query_view;

statement ok
DROP VIEW mapping_view;

# ==============================================================================
# PRESET PARAMETER TEST
# ==============================================================================

query II
SELECT read_id, reference
FROM align_minimap2_sharded('queries',
    shard_directory := 'data/shards/',
    read_to_shard := 'read_to_shard',
    preset := 'map-ont',
    max_secondary := 0)
WHERE flags & 4 = 0
ORDER BY read_id;
----
query1	ref1
query2	ref2

# ==============================================================================
# CLEANUP
# ==============================================================================

statement ok
DROP TABLE queries;

statement ok
DROP TABLE read_to_shard;

statement ok
DROP TABLE shard_a_subjects;

statement ok
DROP TABLE shard_b_subjects;

# Note: Shard .mmi files (shard_a.mmi, shard_b.mmi) left in data/shards/
# DuckDB test framework does not clean these up automatically
