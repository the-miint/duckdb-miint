# name: test/sql/read_sam.test
# description: test read_sam table function
# group: [sql]

statement ok
PRAGMA enable_verification;

# Before we load the extension, this will fail
statement error
SELECT * FROM read_sam('foo');
----
Catalog Error: Table Function with name read_sam does not exist!

# Require statement will ensure this test is run with this extension loaded
require miint

###############################################################################
# ERROR HANDLING TESTS
###############################################################################

# Confirm the extension fails when files are not found (single file)
statement error
SELECT * FROM read_sam('missing_file.sam');
----
IO Error: File not found: missing_file.sam

# Confirm the extension fails when files are not found (multi-file)
statement error
SELECT * FROM read_sam(['data/sam/foo_has_header.sam', 'missing_file.sam']);
----
IO Error: File not found: missing_file.sam

# Confirm error as we lack reference information for headerless SAM
statement error
SELECT * FROM read_sam('data/sam/foo_no_header.sam');
----
IO Error: File lacks a header, and no reference information provided

# Confirm that incomplete reference information results in unmapped records
# (records with missing references appear as unmapped with reference "*")
query ITI
SELECT read_id, reference, flags FROM read_sam('data/sam/foo_no_header.sam', reference_lengths=MAP(['G1234'], [20]));
----
foo-1	G1234	0
foo-2	G1234	0
foo-3	*	103
foo-3	*	151

# Confirm error passing reference information and SAM with header (conflict)
statement error
SELECT * FROM read_sam('data/sam/foo_has_header.sam', reference_lengths=MAP(['G1234'], [20]));
----
IO Error: SAM file has header, but reference_lengths parameter was provided

# Confirm error with mixed headers in multi-file (first has header, second doesn't)
statement error
SELECT * FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_no_header.sam']);
----
IO Error: Inconsistent headers across files: 'data/sam/foo_has_header.sam' has header, 'data/sam/foo_no_header.sam' does not

# Confirm error with mixed headers in multi-file (first doesn't, second does)
statement error
SELECT * FROM read_sam(['data/sam/foo_no_header.sam', 'data/sam/foo_has_header.sam'], reference_lengths=MAP(['G1234', 'G000144735'], [20, 90]));
----
IO Error: Inconsistent headers across files: 'data/sam/foo_no_header.sam' lacks header, 'data/sam/foo_has_header.sam' has header

###############################################################################
# BASIC FUNCTIONALITY TESTS
###############################################################################

# Single file with header - verify all 21 columns
# Schema: read_id, flags, reference, position, stop_position, mapq, cigar, mate_reference, mate_position, template_length,
#         tag_as, tag_xs, tag_ys, tag_xn, tag_xm, tag_xo, tag_xg, tag_nm, tag_yt, tag_md, tag_sa
query IIIIIIITTIIIIIIIIITTT
SELECT * FROM read_sam('data/sam/foo_has_header.sam');
----
foo-1	0	G1234	2	12	60	10M	*	0	0	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-2	0	G1234	2	12	60	10M	*	0	0	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-3	99	G000144735	76020	76170	1	150M	=	76146	276	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-3	147	G000144735	76146	76296	1	150M	=	76020	-276	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

# Single file with header (VARCHAR input)
query I
SELECT COUNT(*) FROM read_sam('data/sam/foo_has_header.sam');
----
4

# Single file headerless with reference_lengths
query IIIIIIITTIIIIIIIIITTT
SELECT * FROM read_sam('data/sam/foo_no_header.sam', reference_lengths=MAP(['G1234', 'G000144735'], [20, 90]));
----
foo-1	0	G1234	2	12	60	10M	*	0	0	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-2	0	G1234	2	12	60	10M	*	0	0	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-3	99	G000144735	76020	76170	1	150M	=	76146	276	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
foo-3	147	G000144735	76146	76296	1	150M	=	76020	-276	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

# Single file headerless with extra references in reference_lengths (should be OK)
query I
SELECT COUNT(*) FROM read_sam('data/sam/foo_no_header.sam', reference_lengths=MAP(['G1234', 'G000144735', 'G999999'], [20, 90, 100]));
----
4

# Multi-file with headers (VARCHAR[] input)
query I
SELECT COUNT(*) FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam']);
----
8

# Multi-file with headers - verify ordering (file1 then file2)
query IT
SELECT read_id, reference FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam']);
----
foo-1	G1234
foo-2	G1234
foo-3	G000144735
foo-3	G000144735
bar-1	G1234
bar-2	G000144735
bar-2	G000144735
bar-3	G1234

# Multi-file headerless with reference_lengths
query I
SELECT COUNT(*) FROM read_sam(['data/sam/foo_no_header.sam', 'data/sam/foo_no_header_2.sam'], reference_lengths=MAP(['G1234', 'G000144735'], [20, 90]));
----
8

###############################################################################
# INCLUDE_FILEPATH TESTS
###############################################################################

# Single file without include_filepath (default) - should have 21 columns
query I
SELECT COUNT(*) FROM (SELECT * FROM read_sam('data/sam/foo_has_header.sam')) AS t(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21);
----
4

# Single file with include_filepath=false - should have 21 columns
query I
SELECT COUNT(*) FROM (SELECT * FROM read_sam('data/sam/foo_has_header.sam', include_filepath=false)) AS t(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21);
----
4

# Single file with include_filepath=true - should have 22 columns with filepath at end
query IT
SELECT read_id, filepath FROM read_sam('data/sam/foo_has_header.sam', include_filepath=true);
----
foo-1	data/sam/foo_has_header.sam
foo-2	data/sam/foo_has_header.sam
foo-3	data/sam/foo_has_header.sam
foo-3	data/sam/foo_has_header.sam

# Multi-file with include_filepath=true - verify filepath column distinguishes files
query ITT
SELECT read_id, reference, filepath FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam'], include_filepath=true);
----
foo-1	G1234	data/sam/foo_has_header.sam
foo-2	G1234	data/sam/foo_has_header.sam
foo-3	G000144735	data/sam/foo_has_header.sam
foo-3	G000144735	data/sam/foo_has_header.sam
bar-1	G1234	data/sam/foo_has_header_2.sam
bar-2	G000144735	data/sam/foo_has_header_2.sam
bar-2	G000144735	data/sam/foo_has_header_2.sam
bar-3	G1234	data/sam/foo_has_header_2.sam

###############################################################################
# EDGE CASES
###############################################################################

# Empty SAM file with header
query I
SELECT COUNT(*) FROM read_sam('data/sam/foo_empty_has_header.sam');
----
0

# File with records containing optional tags (verify non-null tags)
# This uses a file with actual bowtie2/minimap2 tags
query IIIIIIITTIIIIIIIIITTT
SELECT * FROM read_sam('data/sam/foo_with_tags.sam');
----
tagged-1	0	G1234	10	60	60	50M	*	0	0	100	90	NULL	5	3	1	2	4	CP	10A5T20	NULL
tagged-2	99	G000144735	1000	1100	30	100M	=	1200	300	200	180	150	NULL	NULL	NULL	NULL	10	UU	NULL	chr1,1234,+,50M,60,5;

# File with records missing all optional tags (verify all NULL)
query IIIIIIITTIIIIIIIIITTT
SELECT * FROM read_sam('data/sam/foo_no_tags.sam');
----
notag-1	0	G1234	5	30	60	25M	*	0	0	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

###############################################################################
# ORDERING TESTS
###############################################################################

# Test that ORDER BY works for grouping by read_id across multiple files
query IT
SELECT read_id, reference FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam']) ORDER BY read_id, reference;
----
bar-1	G1234
bar-2	G000144735
bar-2	G000144735
bar-3	G1234
foo-1	G1234
foo-2	G1234
foo-3	G000144735
foo-3	G000144735

# Verify ORDER BY works with include_filepath
query ITT
SELECT read_id, reference, filepath FROM read_sam(['data/sam/foo_has_header.sam', 'data/sam/foo_has_header_2.sam'], include_filepath=true) ORDER BY read_id, filepath;
----
bar-1	G1234	data/sam/foo_has_header_2.sam
bar-2	G000144735	data/sam/foo_has_header_2.sam
bar-2	G000144735	data/sam/foo_has_header_2.sam
bar-3	G1234	data/sam/foo_has_header_2.sam
foo-1	G1234	data/sam/foo_has_header.sam
foo-2	G1234	data/sam/foo_has_header.sam
foo-3	G000144735	data/sam/foo_has_header.sam
foo-3	G000144735	data/sam/foo_has_header.sam

###############################################################################
# DATA TYPE VERIFICATION
###############################################################################

# Verify BIGINT for positions (can handle large genomic coordinates)
query IIIIIIIIII
SELECT read_id, flags, reference, position, stop_position, mapq, cigar, mate_reference, mate_position, template_length 
FROM read_sam('data/sam/foo_large_positions.sam');
----
large-pos	0	chrLarge	2147483648	2147483748	60	100M	=	2147483748	200

# Verify nullable integer tags return NULL properly
query IIIIIIII
SELECT tag_as, tag_xs, tag_ys, tag_xn, tag_xm, tag_xo, tag_xg, tag_nm 
FROM read_sam('data/sam/foo_has_header.sam') 
WHERE read_id = 'foo-1';
----
NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL

# Verify nullable string tags return NULL properly
query TTT
SELECT tag_yt, tag_md, tag_sa 
FROM read_sam('data/sam/foo_has_header.sam') 
WHERE read_id = 'foo-1';
----
NULL	NULL	NULL
