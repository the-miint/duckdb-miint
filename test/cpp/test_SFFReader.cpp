#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_string.hpp>
#include <SFFReader.hpp>

// Test data files are in data/sff/ (generated by test/scripts/generate_sff_test_data.py)
static const std::string DATA_DIR = "data/sff/";

// Expected values from generate_sff_test_data.py (raw Phred scores, NOT offset)
// basic_2reads.sff: 2 reads, no trimming (all clips=0)
// READ_1: seq="TCAGATTGCAGG", qual=[30,30,25,35,40,38,36,30,28,25,20,15]
// READ_2: seq="TCAGCCTAAGTC", qual=[35,35,30,40,38,33,30,28,35,30,25,20]

// ===== Phase 2: Header Parsing =====

TEST_CASE("SFFReader rejects empty file", "[sff][header]") {
	// empty.sff has a valid header with 0 reads - the file itself is not empty,
	// but it has 0 reads which is a valid edge case. We test truly empty files
	// by checking the truncated_header case below.
	// For 0-read files, the constructor should succeed (valid header).
	// This test verifies that a file with 0 reads parses successfully.
	miint::SFFReader reader(DATA_DIR + "empty.sff", false);
	CHECK(reader.number_of_reads() == 0);
}

TEST_CASE("SFFReader rejects file smaller than 31 bytes", "[sff][header]") {
	CHECK_THROWS_WITH(miint::SFFReader(DATA_DIR + "truncated_header.sff", false),
	                  Catch::Matchers::ContainsSubstring("too small"));
}

TEST_CASE("SFFReader rejects wrong magic number", "[sff][header]") {
	CHECK_THROWS_WITH(miint::SFFReader(DATA_DIR + "bad_magic.sff", false), Catch::Matchers::ContainsSubstring("magic"));
}

TEST_CASE("SFFReader rejects wrong version", "[sff][header]") {
	CHECK_THROWS_WITH(miint::SFFReader(DATA_DIR + "bad_version.sff", false),
	                  Catch::Matchers::ContainsSubstring("version"));
}

TEST_CASE("SFFReader rejects nonexistent file", "[sff][header]") {
	CHECK_THROWS_WITH(miint::SFFReader("nonexistent.sff", false), Catch::Matchers::ContainsSubstring("open"));
}

TEST_CASE("SFFReader parses valid header", "[sff][header]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", false);

	CHECK(reader.number_of_reads() == 2);
	CHECK(reader.number_of_flows() == 4);
	CHECK(reader.flow_chars() == "TACG");
	CHECK(reader.key_sequence() == "TCAG");
}

TEST_CASE("SFFReader parses header with index offset", "[sff][header]") {
	miint::SFFReader reader(DATA_DIR + "with_index.sff", false);

	CHECK(reader.number_of_reads() == 2);
	CHECK(reader.number_of_flows() == 4);
	CHECK(reader.index_offset() > 0);
	CHECK(reader.index_length() > 0);
}

TEST_CASE("SFFReader parses single read file header", "[sff][header]") {
	miint::SFFReader reader(DATA_DIR + "single_read.sff", false);
	CHECK(reader.number_of_reads() == 1);
}

TEST_CASE("SFFReader parses many reads file header", "[sff][header]") {
	miint::SFFReader reader(DATA_DIR + "many_reads.sff", false);
	CHECK(reader.number_of_reads() == 50);
}

// ===== Phase 3: Single Read Parsing =====

TEST_CASE("SFFReader reads first record correctly", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", /*trim=*/false);
	auto batch = reader.read(1);

	REQUIRE(batch.size() == 1);
	CHECK(batch.read_ids[0] == "READ_1");
	CHECK(batch.sequences1[0] == "TCAGATTGCAGG");
	CHECK(batch.comments[0].empty());
	CHECK(batch.is_paired == false);

	// Quality scores: raw Phred [30,30,25,35,40,38,36,30,28,25,20,15]
	// Stored internally as Phred+33 ASCII, retrieved via as_vec(33)
	auto qual_vec = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual = {30, 30, 25, 35, 40, 38, 36, 30, 28, 25, 20, 15};
	REQUIRE(qual_vec.size() == expected_qual.size());
	for (size_t i = 0; i < expected_qual.size(); i++) {
		CHECK(qual_vec[i] == expected_qual[i]);
	}
}

TEST_CASE("SFFReader reads all records sequentially", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", /*trim=*/false);

	// Read both records one at a time
	auto batch1 = reader.read(1);
	REQUIRE(batch1.size() == 1);
	CHECK(batch1.read_ids[0] == "READ_1");
	CHECK(batch1.sequences1[0] == "TCAGATTGCAGG");

	auto batch2 = reader.read(1);
	REQUIRE(batch2.size() == 1);
	CHECK(batch2.read_ids[0] == "READ_2");
	CHECK(batch2.sequences1[0] == "TCAGCCTAAGTC");

	auto qual_vec2 = batch2.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual2 = {35, 35, 30, 40, 38, 33, 30, 28, 35, 30, 25, 20};
	REQUIRE(qual_vec2.size() == expected_qual2.size());
	for (size_t i = 0; i < expected_qual2.size(); i++) {
		CHECK(qual_vec2[i] == expected_qual2[i]);
	}

	// EOF: should return empty batch
	auto batch3 = reader.read(1);
	CHECK(batch3.empty());
}

TEST_CASE("SFFReader reads all records in single batch", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", /*trim=*/false);
	auto batch = reader.read(10); // request more than available

	REQUIRE(batch.size() == 2);
	CHECK(batch.read_ids[0] == "READ_1");
	CHECK(batch.read_ids[1] == "READ_2");
	CHECK(batch.sequences1[0] == "TCAGATTGCAGG");
	CHECK(batch.sequences1[1] == "TCAGCCTAAGTC");
}

TEST_CASE("SFFReader skips index block during sequential read", "[sff][read]") {
	// with_index.sff has: header | read1 | index_block | read2
	// Same reads as basic_2reads.sff
	miint::SFFReader reader(DATA_DIR + "with_index.sff", /*trim=*/false);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 2);
	CHECK(batch.read_ids[0] == "READ_1");
	CHECK(batch.read_ids[1] == "READ_2");
	CHECK(batch.sequences1[0] == "TCAGATTGCAGG");
	CHECK(batch.sequences1[1] == "TCAGCCTAAGTC");
}

TEST_CASE("SFFReader reads single_read.sff", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "single_read.sff", /*trim=*/false);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 1);
	CHECK(batch.read_ids[0] == "SINGLE");
	CHECK(batch.sequences1[0] == "ACGT");

	auto qual_vec = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected = {40, 35, 30, 25};
	REQUIRE(qual_vec.size() == expected.size());
	for (size_t i = 0; i < expected.size(); i++) {
		CHECK(qual_vec[i] == expected[i]);
	}
}

TEST_CASE("SFFReader throws on truncated read data", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "truncated_read.sff", /*trim=*/false);
	CHECK_THROWS_WITH(reader.read(1), Catch::Matchers::ContainsSubstring("truncated"));
}

TEST_CASE("SFFReader read after EOF returns empty", "[sff][read]") {
	miint::SFFReader reader(DATA_DIR + "empty.sff", /*trim=*/false);
	auto batch = reader.read(1);
	CHECK(batch.empty());
}

// ===== Malformed Input Validation (#12) =====

TEST_CASE("SFFReader rejects absurd seq_len", "[sff][malformed]") {
	// bad_seq_len.sff has seq_len patched to UINT32_MAX
	miint::SFFReader reader(DATA_DIR + "bad_seq_len.sff", false);
	CHECK_THROWS_WITH(reader.read(1), Catch::Matchers::ContainsSubstring("exceeds maximum"));
}

TEST_CASE("SFFReader rejects clip coordinate exceeding seq_len", "[sff][malformed]") {
	// bad_clip.sff has clip_qual_right=100 but seq_len=4
	miint::SFFReader reader(DATA_DIR + "bad_clip.sff", false);
	CHECK_THROWS_WITH(reader.read(1), Catch::Matchers::ContainsSubstring("clip_qual_right"));
}

TEST_CASE("SFFReader handles overclaimed read count gracefully", "[sff][malformed]") {
	// overclaimed_reads.sff: header says 10 reads but only 1 exists
	miint::SFFReader reader(DATA_DIR + "overclaimed_reads.sff", false);

	// First read should succeed
	auto batch1 = reader.read(1);
	REQUIRE(batch1.size() == 1);
	CHECK(batch1.read_ids[0] == "ONLY_ONE");

	// Second read should fail because file is truncated
	CHECK_THROWS_WITH(reader.read(1), Catch::Matchers::ContainsSubstring("truncated"));
}

// ===== Phase 4: Trimming Logic =====

TEST_CASE("SFFReader applies quality and adapter trimming correctly", "[sff][trim]") {
	// trimmed.sff has 2 reads with non-trivial clip values on all 4 fields
	miint::SFFReader reader(DATA_DIR + "trimmed.sff", /*trim=*/true);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 2);

	// TRIM_READ_1: full="AATCAGATTGCAGGCC" (len=16)
	//   clip_qual_left=3, clip_qual_right=14, clip_adapter_left=2, clip_adapter_right=15
	//   effective_left  = max(3, 2) - 1 = 2  (0-based)
	//   effective_right = min(14, 15) = 14    (1-based inclusive)
	//   trimmed sequence: "TCAGATTGCAGG" (positions 2..13 inclusive, 0-based)
	//   trimmed quality:  [30, 30, 25, 35, 40, 38, 36, 30, 28, 25, 20, 15]
	CHECK(batch.read_ids[0] == "TRIM_READ_1");
	CHECK(batch.sequences1[0] == "TCAGATTGCAGG");
	auto qual1 = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual1 = {30, 30, 25, 35, 40, 38, 36, 30, 28, 25, 20, 15};
	REQUIRE(qual1.size() == expected_qual1.size());
	for (size_t i = 0; i < expected_qual1.size(); i++) {
		CHECK(qual1[i] == expected_qual1[i]);
	}

	// TRIM_READ_2: full="NNTCAGCCTAAGTCNN" (len=16)
	//   clip_qual_left=3, clip_qual_right=14, clip_adapter_left=4, clip_adapter_right=13
	//   effective_left  = max(3, 4) - 1 = 3  (0-based)
	//   effective_right = min(14, 13) = 13    (exclusive end)
	//   trimmed sequence: "CAGCCTAAGT" (positions 3..12 inclusive, 0-based)
	//   trimmed quality:  [30, 35, 30, 40, 38, 33, 30, 28, 35, 30]
	//   NOTE: generator comment had wrong expected sequence "AGCCTAAGTC" (was off-by-one)
	CHECK(batch.read_ids[1] == "TRIM_READ_2");
	CHECK(batch.sequences1[1] == "CAGCCTAAGT");
	auto qual2 = batch.quals1[1].as_vec(33);
	std::vector<uint8_t> expected_qual2 = {30, 35, 30, 40, 38, 33, 30, 28, 35, 30};
	REQUIRE(qual2.size() == expected_qual2.size());
	for (size_t i = 0; i < expected_qual2.size(); i++) {
		CHECK(qual2[i] == expected_qual2[i]);
	}
}

TEST_CASE("SFFReader handles clip values of 0 (no clip)", "[sff][trim]") {
	// no_clip.sff: all clips=0, should return full sequence regardless of trim setting
	miint::SFFReader reader(DATA_DIR + "no_clip.sff", /*trim=*/true);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 2);

	CHECK(batch.read_ids[0] == "NOCLIP_1");
	CHECK(batch.sequences1[0] == "ACGTACGT");
	auto qual1 = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual1 = {40, 40, 35, 35, 30, 30, 25, 25};
	REQUIRE(qual1.size() == expected_qual1.size());
	for (size_t i = 0; i < expected_qual1.size(); i++) {
		CHECK(qual1[i] == expected_qual1[i]);
	}

	CHECK(batch.read_ids[1] == "NOCLIP_2");
	CHECK(batch.sequences1[1] == "TGCATGCA");
	auto qual2 = batch.quals1[1].as_vec(33);
	std::vector<uint8_t> expected_qual2 = {38, 38, 33, 33, 28, 28, 23, 23};
	REQUIRE(qual2.size() == expected_qual2.size());
	for (size_t i = 0; i < expected_qual2.size(); i++) {
		CHECK(qual2[i] == expected_qual2[i]);
	}
}

TEST_CASE("SFFReader handles adapter-only clips", "[sff][trim]") {
	// adapter_only_clip.sff: adapter clips set, qual clips=0
	miint::SFFReader reader(DATA_DIR + "adapter_only_clip.sff", /*trim=*/true);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 2);

	// ADAPT_1: full="NNTCAGATTGCAGGNN" (len=16)
	//   clip_qual_left=0, clip_qual_right=0, clip_adapter_left=3, clip_adapter_right=14
	//   effective_left  = max(1, 3) - 1 = 2  (0-based)
	//   effective_right = min(16, 14) = 14
	//   trimmed: "TCAGATTGCAGG" (positions 2..13, 0-based)
	CHECK(batch.read_ids[0] == "ADAPT_1");
	CHECK(batch.sequences1[0] == "TCAGATTGCAGG");
	auto qual1 = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual1 = {30, 30, 25, 35, 40, 38, 36, 30, 28, 25, 20, 15};
	REQUIRE(qual1.size() == expected_qual1.size());
	for (size_t i = 0; i < expected_qual1.size(); i++) {
		CHECK(qual1[i] == expected_qual1[i]);
	}

	// ADAPT_2: full="NTCAGCCTAAGTCN" (len=14)
	//   clip_qual_left=0, clip_qual_right=0, clip_adapter_left=2, clip_adapter_right=13
	//   effective_left  = max(1, 2) - 1 = 1
	//   effective_right = min(14, 13) = 13
	//   trimmed: "TCAGCCTAAGTC" (positions 1..12, 0-based)
	CHECK(batch.read_ids[1] == "ADAPT_2");
	CHECK(batch.sequences1[1] == "TCAGCCTAAGTC");
	auto qual2 = batch.quals1[1].as_vec(33);
	std::vector<uint8_t> expected_qual2 = {35, 35, 30, 40, 38, 33, 30, 28, 35, 30, 25, 20};
	REQUIRE(qual2.size() == expected_qual2.size());
	for (size_t i = 0; i < expected_qual2.size(); i++) {
		CHECK(qual2[i] == expected_qual2[i]);
	}
}

TEST_CASE("SFFReader trim=false returns untrimmed data", "[sff][trim]") {
	// trimmed.sff with trim=false should return full sequences
	miint::SFFReader reader(DATA_DIR + "trimmed.sff", /*trim=*/false);
	auto batch = reader.read(10);

	REQUIRE(batch.size() == 2);

	CHECK(batch.read_ids[0] == "TRIM_READ_1");
	CHECK(batch.sequences1[0] == "AATCAGATTGCAGGCC");
	auto qual1 = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected_qual1 = {5, 8, 30, 30, 25, 35, 40, 38, 36, 30, 28, 25, 20, 15, 8, 5};
	REQUIRE(qual1.size() == expected_qual1.size());
	for (size_t i = 0; i < expected_qual1.size(); i++) {
		CHECK(qual1[i] == expected_qual1[i]);
	}

	CHECK(batch.read_ids[1] == "TRIM_READ_2");
	CHECK(batch.sequences1[1] == "NNTCAGCCTAAGTCNN");
	auto qual2 = batch.quals1[1].as_vec(33);
	std::vector<uint8_t> expected_qual2 = {2, 2, 10, 30, 35, 30, 40, 38, 33, 30, 28, 35, 30, 10, 2, 2};
	REQUIRE(qual2.size() == expected_qual2.size());
	for (size_t i = 0; i < expected_qual2.size(); i++) {
		CHECK(qual2[i] == expected_qual2[i]);
	}
}

// ===== Phase 7: Edge Cases & Hardening =====

TEST_CASE("SFFReader handles read with empty sequence after trim", "[sff][edge]") {
	// overlapping_clips.sff: clip_qual_left=6, clip_qual_right=3
	// effective_left (5) >= effective_right (3) -> empty result
	miint::SFFReader reader(DATA_DIR + "overlapping_clips.sff", /*trim=*/true);
	auto batch = reader.read(1);

	REQUIRE(batch.size() == 1);
	CHECK(batch.read_ids[0] == "OVERLAP_CLIP");
	CHECK(batch.sequences1[0].empty());
	CHECK(batch.quals1[0].as_vec(33).empty());
}

TEST_CASE("SFFReader overlapping clips with trim=false returns full data", "[sff][edge]") {
	// Same file but trim=false should return the full sequence
	miint::SFFReader reader(DATA_DIR + "overlapping_clips.sff", /*trim=*/false);
	auto batch = reader.read(1);

	REQUIRE(batch.size() == 1);
	CHECK(batch.read_ids[0] == "OVERLAP_CLIP");
	CHECK(batch.sequences1[0] == "ACGTACGT");
	auto qual_vec = batch.quals1[0].as_vec(33);
	std::vector<uint8_t> expected = {40, 35, 30, 25, 20, 15, 10, 5};
	REQUIRE(qual_vec.size() == expected.size());
	for (size_t i = 0; i < expected.size(); i++) {
		CHECK(qual_vec[i] == expected[i]);
	}
}

TEST_CASE("SFFReader read(0) returns empty batch", "[sff][edge]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", /*trim=*/false);
	auto batch = reader.read(0);
	CHECK(batch.empty());

	// Subsequent normal read should still work
	auto batch2 = reader.read(1);
	REQUIRE(batch2.size() == 1);
	CHECK(batch2.read_ids[0] == "READ_1");
}

TEST_CASE("SFFReader read(-1) returns empty batch", "[sff][edge]") {
	miint::SFFReader reader(DATA_DIR + "basic_2reads.sff", /*trim=*/false);
	auto batch = reader.read(-1);
	CHECK(batch.empty());

	// Subsequent normal read should still work
	auto batch2 = reader.read(1);
	REQUIRE(batch2.size() == 1);
	CHECK(batch2.read_ids[0] == "READ_1");
}

// ===== Phase 5: Batch Reading API =====

TEST_CASE("SFFReader sequential batches cover all records", "[sff][batch]") {
	// many_reads.sff has 50 reads named MANYREAD_01 through MANYREAD_50
	miint::SFFReader reader(DATA_DIR + "many_reads.sff", /*trim=*/false);

	size_t total_records = 0;
	int batch_count = 0;
	std::vector<std::string> all_names;

	while (true) {
		auto batch = reader.read(10);
		if (batch.empty()) {
			break;
		}
		total_records += batch.size();
		batch_count++;
		for (const auto &name : batch.read_ids) {
			all_names.push_back(name);
		}
	}

	// 50 reads in batches of 10 = exactly 5 batches
	CHECK(total_records == 50);
	CHECK(batch_count == 5);

	// Verify read names are sequential MANYREAD_01..MANYREAD_50
	REQUIRE(all_names.size() == 50);
	for (int i = 0; i < 50; i++) {
		char expected_name[16];
		snprintf(expected_name, sizeof(expected_name), "MANYREAD_%02d", i + 1);
		CHECK(all_names[i] == expected_name);
	}
}
